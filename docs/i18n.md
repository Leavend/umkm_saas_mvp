# Internationalization & Pathname Localization

This application uses a lightweight locale system tailored for Indonesian (`id`) and English (`en`) with fully localized path segments and slugs. This document explains the moving pieces and how to extend the system.

## Locale definition

* `src/lib/i18n/locales.ts` declares the `locales` tuple, the `Locale` type alias, the `defaultLocale` (`id`), and helpers to normalise incoming locale values.
* `src/lib/i18n.ts` re-exports the locale helpers alongside the translation catalogue consumed by UI components.

## Pathname mapping

* `src/lib/i18n/pathnames.ts` contains the canonical → localized path map. Each key is the canonical route template (e.g. `/dashboard`, `/blog/[slug]`). Values can be either a string (when the path is identical for all locales) or an object keyed by locale with the localized path segment.
* `localizePathname(template, locale)` resolves a template to the localized path (still containing dynamic placeholders such as `[slug]`).
* `matchLocalizedPathname(pathname, locale)` in `src/lib/i18n/matcher.ts` reverses a localized pathname back to its canonical template and extracts dynamic parameters.

When adding a new route, register it inside `pathnames.ts`. Route aliases such as `/dasbor` are implemented by pointing to the same canonical template and providing the translated segment.

## Navigation helpers

`src/lib/i18n/navigation.tsx` exports:

* `localizedHref(locale, href)` – builds a localized URL string for canonical routes. Accepts a string template (`"/dashboard"`) or an object containing `pathname`, `params`, optional `query`, and `hash` values.
* `Link` – a thin wrapper around `next/link` that requires an explicit `locale` prop. The component works in Server Components and Client Components and forwards refs as expected.
* `useLocalizedRouter(locale)` – client-side helper that mirrors Next.js' router API but automatically localizes the destination URL.

Always prefer these helpers over raw `next/link` to ensure URLs stay localized.

## Slug localisation

Dynamic routes (blog posts, products) rely on locale-specific slugs stored alongside a stable ID.

* Data lives in `src/lib/content`. Each record conforms to the `LocalizedSlugRecord` interface from `src/lib/i18n/slug.ts` (`id`, `slug_en`, `slug_id`).
* `pickSlug(record, locale)` returns the slug for a locale.
* `invertSlugMap(records, locale)` builds a map of `slug → record` for lookups.
* `src/lib/i18n/slug-resolver.ts` centralises slug aware utilities:
  * `resolveLocalizedSlug(template, currentSlug, fromLocale, toLocale)` swaps slugs when switching locales.
  * `listLocalizedSlugs(template, locale)` enumerates slugs per locale for `generateStaticParams`.
  * `getLocalizedRecord<T>()` fetches the full record behind a slug without re-implementing lookups in every page.

When introducing a new dynamic route ensure the dataset implements `LocalizedSlugRecord`, register it inside `slug-resolver.ts`, and use the helpers inside the corresponding page modules.

## Middleware / proxy

* `src/app/proxy.ts` performs locale negotiation using the `Accept-Language` header (via `negotiator` and `@formatjs/intl-localematcher`). Requests without a locale segment are redirected to `/{resolvedLocale}`.
* The legacy `src/middleware.ts` file has been removed to avoid double redirects.

## Layout behaviour

* `app/[lang]/layout.tsx` wires global fonts, providers, and generates locale-aware `<link rel="alternate">` entries.
* `generateStaticParams` exposes every locale at build time, while `generateMetadata` sets canonical URLs per locale.

## Language toggle

* `src/components/language-toggle.tsx` reads the current pathname, infers the canonical template (`matchLocalizedPathname`), optionally transforms dynamic slugs (`resolveLocalizedSlug`), and pushes the alternate locale using `localizedHref`.
* Locale preference is persisted to cookies and `localStorage` via `src/actions/set-locale.ts`.

## Adding a new route

1. Register the canonical template in `src/lib/i18n/pathnames.ts` with localized segments.
2. Update `slug-resolver.ts` if the route carries localized slugs.
3. Build the page component under `app/[lang]/…` using the canonical name (e.g. `products/[slug]/page.tsx`). For additional locale-specific segments create re-exporting folders (`produk/[slug]/page.tsx`).
4. Prefer `Link` and `localizedHref` for internal navigation.
5. Update or add tests in `tests/unit` to cover the new helpers if necessary.

## Testing

* Unit tests in `tests/unit` cover the navigation helper and slug resolver (using the Node built-in test runner).
* A Playwright scenario lives in `tests/e2e/language-switch.spec.ts` and is marked as `skip` until the CI environment provides Playwright binaries.

With these pieces in place the app delivers consistent, localized routing for both locales while keeping canonical route definitions centralized.
